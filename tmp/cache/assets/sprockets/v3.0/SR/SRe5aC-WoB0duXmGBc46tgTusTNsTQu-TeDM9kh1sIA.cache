I"!	(function() {
  var _queueSingleton;

  App.QueueManager = (function() {
    var _instance;

    function QueueManager() {}

    _instance = void 0;

    QueueManager.init = function() {
      return _instance != null ? _instance : _instance = new _queueSingleton;
    };

    QueueManager.add = function(key, data) {
      if (_instance === void 0) {
        if (_instance == null) {
          _instance = new _queueSingleton;
        }
      }
      return _instance.add(key, data);
    };

    QueueManager.pull = function(key) {
      if (_instance === void 0) {
        if (_instance == null) {
          _instance = new _queueSingleton;
        }
      }
      return _instance.pull(key);
    };

    QueueManager.all = function(key) {
      if (_instance === void 0) {
        if (_instance == null) {
          _instance = new _queueSingleton;
        }
      }
      return _instance.all(key);
    };

    QueueManager.run = function(key, callback) {
      if (_instance === void 0) {
        if (_instance == null) {
          _instance = new _queueSingleton;
        }
      }
      return _instance.run(key, callback);
    };

    return QueueManager;

  })();

  _queueSingleton = (function() {
    function _queueSingleton() {
      this.queues = {};
      this.queueRunning = {};
    }

    _queueSingleton.prototype.add = function(key, data) {
      if (!this.queues[key]) {
        this.queues[key] = [];
      }
      this.queues[key].push(data);
      return true;
    };

    _queueSingleton.prototype.pull = function(key) {
      if (!this.queues[key]) {
        return;
      }
      return this.queues[key].shift();
    };

    _queueSingleton.prototype.all = function(key) {
      return this.queues[key];
    };

    _queueSingleton.prototype.run = function(key, callback) {
      var localQueue;
      if (!this.queues[key]) {
        return;
      }
      if (this.queueRunning[key]) {
        return;
      }
      localQueue = this.queues[key];
      if (_.isEmpty(localQueue)) {
        return;
      }
      this.queueRunning[key] = true;
      while (true) {
        callback = localQueue.shift();
        callback();
        if (!localQueue[0]) {
          this.queueRunning[key] = false;
          break;
        }
      }
      return true;
    };

    return _queueSingleton;

  })();

}).call(this);
:ET